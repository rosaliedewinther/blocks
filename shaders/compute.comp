#version 460

float PI = 3.1415926538;
float sqrt_three = 1.732050808;
uint VIEWTYPE_STANDARD = 1;
uint VIEWTYPE_COMPLEXITY = 2;
uint VIEWTYPE_UNSHADED = 3;


struct Uniforms{
    vec3 position;
    float time;
    vec3 direction;
    vec3 sun_dir;
    uint world_size;
    uint view_type;
    vec3[3] ray_cast_data;
    vec4[16] colors;
};
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(rgba8ui, binding = 0) writeonly uniform uimage2D img_output;
layout(rgba8ui, binding = 1) readonly uniform uimage3D world;
layout(rgba8ui, binding = 2) readonly uniform uimage3D sdf;
layout(binding=3) readonly uniform camera_details{
    Uniforms uni;
};

vec3 rotation_x(vec3 v, float angle){
    float s = sin(angle);
    float c = cos(angle);

    mat3 matrix = mat3(
        1.0, 0.0, 0.0,
        0.0, c, s,
        0.0, -s, c
    );
    return matrix*v;
}
vec3 rotation_y(vec3 v, float angle){
    float s = sin(angle);
    float c = cos(angle);
    mat3 matrix = mat3(
        c, 0.0, -s,
        0.0, 1.0, 0.0,
        s, 0.0, c
    );
    return matrix*v;
}
vec3 rotation_z(vec3 v, float angle){
    float s = sin(angle);
    float c = cos(angle);
    mat3 matrix = mat3(
        c, -s, 0.0,
        s, c, 0.0,
        0.0, 0.0, 1.0
    );
    return matrix*v;
}

vec3 generateRayDirection(){
    vec2 pixel_coords = gl_GlobalInvocationID.xy; //real pixel location
    float fov = 60;
    vec3 pij = uni.ray_cast_data[2]+uni.ray_cast_data[0]*(pixel_coords[0]-1) + uni.ray_cast_data[1]*(pixel_coords[1]-1);
    vec3 rij = normalize(pij);
    return rij;
}

uvec4 draw_sun(vec3 direction, uvec4 pixel){
    if (dot(direction, uni.sun_dir) < -0.99 ){
        return pixel + uvec4(pow(dot(direction, uni.sun_dir)*-1,1000) * vec4(255, 245, 127,255));
    }
    return pixel;
}

uvec4 draw_skyline(vec3 direction, uvec4 pixel){
    return uvec4(mix(vec3(200,200,200), vec3(51,102,244), direction[1]), 255);
}

bool block_in_world(ivec3 world_position){
    return
        world_position.x < uni.world_size &&
        world_position.x > -1  &&
        world_position.y < uni.world_size &&
        world_position.y > -1 &&
        world_position.z < uni.world_size &&
        world_position.z > -1;
}

uint get_block_id(ivec3 world_position){
    ivec3 position = ivec3(world_position.x/4, world_position.y, world_position.z);
    int offset = int(mod(world_position.x, 4));
    return uint(imageLoad(world, position)[offset]);
}
uint get_sdf_value(ivec3 world_position){
    ivec3 position = ivec3(world_position.x/4, world_position.y, world_position.z);
    int offset = int(mod(world_position.x, 4));
    return uint(imageLoad(sdf, position)[offset]);
}
vec4 get_voxel_color(uint voxel_id){
    return uni.colors[voxel_id];
}
//https://www.researchgate.net/profile/Kai-Xiao-9/publication/233899848_Efficient_implementation_of_the_3D-DDA_ray_traversal_algorithm_on_GPU_and_its_application_in_radiation_dose_calculation/links/5acfaa9b4585154f3f47bf20/Efficient-implementation-of-the-3D-DDA-ray-traversal-algorithm-on-GPU-and-its-application-in-radiation-dose-calculation.pdf?origin=publication_detail
uvec4 trace_ray(vec3 direction, vec3 origin){
    ivec3 current_voxel = ivec3(origin);
    int iter = 0;

    vec3 deltaDist = abs(vec3(length(direction))/direction);
    vec3 step = ivec3(sign(direction));
    vec3 sideDist = (sign(direction) * (vec3(current_voxel) - origin) + (sign(direction) * 0.5) + 0.5) * deltaDist;

    bvec3 mask;

    while(iter < 500){
        //check if voxel is inside world
        if (!block_in_world(current_voxel)){
            return uvec4(0,0,0,255);
        }
        //check if voxel is hit
        uint sdf_value = get_sdf_value(current_voxel);
        if (sdf_value == 0){
            uint block_id = get_block_id(current_voxel);
            uvec4 voxel = uvec4(get_voxel_color(block_id));
            if (uni.view_type == VIEWTYPE_STANDARD){
                //ty iMplode nZ
                float shadow;
                if (mask.x) {
                    shadow = 0.5;
                }
                if (mask.y) {
                    shadow = 1.0;
                }
                if (mask.z) {
                    shadow = 0.75;
                }
                return uvec4(shadow * voxel.xyz, voxel[3]);
            } else if (uni.view_type == VIEWTYPE_UNSHADED){
                return uvec4(voxel.xyz, voxel[3]);
            } else if (uni.view_type == VIEWTYPE_COMPLEXITY){
                return uvec4(max(pow(1.06, iter),1), 0,0, 255);
            }
        }
        iter+=1;
        if (sdf_value == 1){
            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));
            sideDist += vec3(mask) * deltaDist;
            current_voxel += ivec3(vec3(mask)*step);
        } else {
            current_voxel += ivec3(direction * (sdf_value/sqrt_three));
            sideDist = (sign(direction) * (vec3(current_voxel) - origin) + (sign(direction) * 0.5) + 0.5) * deltaDist;
        }
    }
    return uvec4(0,0,0,255);
}


void main() {
    vec3 origin = uni.position;
    vec3 direction = generateRayDirection();
    uvec4 pixel = trace_ray(direction, origin);
    if (pixel == vec4(0,0,0,255)){
        pixel = draw_skyline(direction, pixel);
        pixel = draw_sun(direction, pixel);
    }
    imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), pixel);
}
